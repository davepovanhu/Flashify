// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'mnemonics_provider.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$MnemonicsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() generating,
    required TResult Function() appending,
    required TResult Function(String message) error,
    required TResult Function(String mnemonic, String? traceId) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? generating,
    TResult? Function()? appending,
    TResult? Function(String message)? error,
    TResult? Function(String mnemonic, String? traceId)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? generating,
    TResult Function()? appending,
    TResult Function(String message)? error,
    TResult Function(String mnemonic, String? traceId)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MnemonicsStateGenerating value) generating,
    required TResult Function(MnemonicsStateAppending value) appending,
    required TResult Function(MnemonicsStateError value) error,
    required TResult Function(MnemonicsStateLoaded value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MnemonicsStateGenerating value)? generating,
    TResult? Function(MnemonicsStateAppending value)? appending,
    TResult? Function(MnemonicsStateError value)? error,
    TResult? Function(MnemonicsStateLoaded value)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MnemonicsStateGenerating value)? generating,
    TResult Function(MnemonicsStateAppending value)? appending,
    TResult Function(MnemonicsStateError value)? error,
    TResult Function(MnemonicsStateLoaded value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MnemonicsStateCopyWith<$Res> {
  factory $MnemonicsStateCopyWith(
          MnemonicsState value, $Res Function(MnemonicsState) then) =
      _$MnemonicsStateCopyWithImpl<$Res, MnemonicsState>;
}

/// @nodoc
class _$MnemonicsStateCopyWithImpl<$Res, $Val extends MnemonicsState>
    implements $MnemonicsStateCopyWith<$Res> {
  _$MnemonicsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MnemonicsStateGeneratingCopyWith<$Res> {
  factory _$$MnemonicsStateGeneratingCopyWith(_$MnemonicsStateGenerating value,
          $Res Function(_$MnemonicsStateGenerating) then) =
      __$$MnemonicsStateGeneratingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MnemonicsStateGeneratingCopyWithImpl<$Res>
    extends _$MnemonicsStateCopyWithImpl<$Res, _$MnemonicsStateGenerating>
    implements _$$MnemonicsStateGeneratingCopyWith<$Res> {
  __$$MnemonicsStateGeneratingCopyWithImpl(_$MnemonicsStateGenerating _value,
      $Res Function(_$MnemonicsStateGenerating) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MnemonicsStateGenerating implements MnemonicsStateGenerating {
  const _$MnemonicsStateGenerating();

  @override
  String toString() {
    return 'MnemonicsState.generating()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MnemonicsStateGenerating);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() generating,
    required TResult Function() appending,
    required TResult Function(String message) error,
    required TResult Function(String mnemonic, String? traceId) loaded,
  }) {
    return generating();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? generating,
    TResult? Function()? appending,
    TResult? Function(String message)? error,
    TResult? Function(String mnemonic, String? traceId)? loaded,
  }) {
    return generating?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? generating,
    TResult Function()? appending,
    TResult Function(String message)? error,
    TResult Function(String mnemonic, String? traceId)? loaded,
    required TResult orElse(),
  }) {
    if (generating != null) {
      return generating();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MnemonicsStateGenerating value) generating,
    required TResult Function(MnemonicsStateAppending value) appending,
    required TResult Function(MnemonicsStateError value) error,
    required TResult Function(MnemonicsStateLoaded value) loaded,
  }) {
    return generating(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MnemonicsStateGenerating value)? generating,
    TResult? Function(MnemonicsStateAppending value)? appending,
    TResult? Function(MnemonicsStateError value)? error,
    TResult? Function(MnemonicsStateLoaded value)? loaded,
  }) {
    return generating?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MnemonicsStateGenerating value)? generating,
    TResult Function(MnemonicsStateAppending value)? appending,
    TResult Function(MnemonicsStateError value)? error,
    TResult Function(MnemonicsStateLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (generating != null) {
      return generating(this);
    }
    return orElse();
  }
}

abstract class MnemonicsStateGenerating implements MnemonicsState {
  const factory MnemonicsStateGenerating() = _$MnemonicsStateGenerating;
}

/// @nodoc
abstract class _$$MnemonicsStateAppendingCopyWith<$Res> {
  factory _$$MnemonicsStateAppendingCopyWith(_$MnemonicsStateAppending value,
          $Res Function(_$MnemonicsStateAppending) then) =
      __$$MnemonicsStateAppendingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MnemonicsStateAppendingCopyWithImpl<$Res>
    extends _$MnemonicsStateCopyWithImpl<$Res, _$MnemonicsStateAppending>
    implements _$$MnemonicsStateAppendingCopyWith<$Res> {
  __$$MnemonicsStateAppendingCopyWithImpl(_$MnemonicsStateAppending _value,
      $Res Function(_$MnemonicsStateAppending) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MnemonicsStateAppending implements MnemonicsStateAppending {
  const _$MnemonicsStateAppending();

  @override
  String toString() {
    return 'MnemonicsState.appending()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MnemonicsStateAppending);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() generating,
    required TResult Function() appending,
    required TResult Function(String message) error,
    required TResult Function(String mnemonic, String? traceId) loaded,
  }) {
    return appending();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? generating,
    TResult? Function()? appending,
    TResult? Function(String message)? error,
    TResult? Function(String mnemonic, String? traceId)? loaded,
  }) {
    return appending?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? generating,
    TResult Function()? appending,
    TResult Function(String message)? error,
    TResult Function(String mnemonic, String? traceId)? loaded,
    required TResult orElse(),
  }) {
    if (appending != null) {
      return appending();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MnemonicsStateGenerating value) generating,
    required TResult Function(MnemonicsStateAppending value) appending,
    required TResult Function(MnemonicsStateError value) error,
    required TResult Function(MnemonicsStateLoaded value) loaded,
  }) {
    return appending(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MnemonicsStateGenerating value)? generating,
    TResult? Function(MnemonicsStateAppending value)? appending,
    TResult? Function(MnemonicsStateError value)? error,
    TResult? Function(MnemonicsStateLoaded value)? loaded,
  }) {
    return appending?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MnemonicsStateGenerating value)? generating,
    TResult Function(MnemonicsStateAppending value)? appending,
    TResult Function(MnemonicsStateError value)? error,
    TResult Function(MnemonicsStateLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (appending != null) {
      return appending(this);
    }
    return orElse();
  }
}

abstract class MnemonicsStateAppending implements MnemonicsState {
  const factory MnemonicsStateAppending() = _$MnemonicsStateAppending;
}

/// @nodoc
abstract class _$$MnemonicsStateErrorCopyWith<$Res> {
  factory _$$MnemonicsStateErrorCopyWith(_$MnemonicsStateError value,
          $Res Function(_$MnemonicsStateError) then) =
      __$$MnemonicsStateErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$MnemonicsStateErrorCopyWithImpl<$Res>
    extends _$MnemonicsStateCopyWithImpl<$Res, _$MnemonicsStateError>
    implements _$$MnemonicsStateErrorCopyWith<$Res> {
  __$$MnemonicsStateErrorCopyWithImpl(
      _$MnemonicsStateError _value, $Res Function(_$MnemonicsStateError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$MnemonicsStateError(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$MnemonicsStateError implements MnemonicsStateError {
  const _$MnemonicsStateError(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'MnemonicsState.error(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MnemonicsStateError &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MnemonicsStateErrorCopyWith<_$MnemonicsStateError> get copyWith =>
      __$$MnemonicsStateErrorCopyWithImpl<_$MnemonicsStateError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() generating,
    required TResult Function() appending,
    required TResult Function(String message) error,
    required TResult Function(String mnemonic, String? traceId) loaded,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? generating,
    TResult? Function()? appending,
    TResult? Function(String message)? error,
    TResult? Function(String mnemonic, String? traceId)? loaded,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? generating,
    TResult Function()? appending,
    TResult Function(String message)? error,
    TResult Function(String mnemonic, String? traceId)? loaded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MnemonicsStateGenerating value) generating,
    required TResult Function(MnemonicsStateAppending value) appending,
    required TResult Function(MnemonicsStateError value) error,
    required TResult Function(MnemonicsStateLoaded value) loaded,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MnemonicsStateGenerating value)? generating,
    TResult? Function(MnemonicsStateAppending value)? appending,
    TResult? Function(MnemonicsStateError value)? error,
    TResult? Function(MnemonicsStateLoaded value)? loaded,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MnemonicsStateGenerating value)? generating,
    TResult Function(MnemonicsStateAppending value)? appending,
    TResult Function(MnemonicsStateError value)? error,
    TResult Function(MnemonicsStateLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class MnemonicsStateError implements MnemonicsState {
  const factory MnemonicsStateError(final String message) =
      _$MnemonicsStateError;

  String get message;
  @JsonKey(ignore: true)
  _$$MnemonicsStateErrorCopyWith<_$MnemonicsStateError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MnemonicsStateLoadedCopyWith<$Res> {
  factory _$$MnemonicsStateLoadedCopyWith(_$MnemonicsStateLoaded value,
          $Res Function(_$MnemonicsStateLoaded) then) =
      __$$MnemonicsStateLoadedCopyWithImpl<$Res>;
  @useResult
  $Res call({String mnemonic, String? traceId});
}

/// @nodoc
class __$$MnemonicsStateLoadedCopyWithImpl<$Res>
    extends _$MnemonicsStateCopyWithImpl<$Res, _$MnemonicsStateLoaded>
    implements _$$MnemonicsStateLoadedCopyWith<$Res> {
  __$$MnemonicsStateLoadedCopyWithImpl(_$MnemonicsStateLoaded _value,
      $Res Function(_$MnemonicsStateLoaded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mnemonic = null,
    Object? traceId = freezed,
  }) {
    return _then(_$MnemonicsStateLoaded(
      mnemonic: null == mnemonic
          ? _value.mnemonic
          : mnemonic // ignore: cast_nullable_to_non_nullable
              as String,
      traceId: freezed == traceId
          ? _value.traceId
          : traceId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$MnemonicsStateLoaded implements MnemonicsStateLoaded {
  const _$MnemonicsStateLoaded({required this.mnemonic, required this.traceId});

  @override
  final String mnemonic;
  @override
  final String? traceId;

  @override
  String toString() {
    return 'MnemonicsState.loaded(mnemonic: $mnemonic, traceId: $traceId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MnemonicsStateLoaded &&
            (identical(other.mnemonic, mnemonic) ||
                other.mnemonic == mnemonic) &&
            (identical(other.traceId, traceId) || other.traceId == traceId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, mnemonic, traceId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MnemonicsStateLoadedCopyWith<_$MnemonicsStateLoaded> get copyWith =>
      __$$MnemonicsStateLoadedCopyWithImpl<_$MnemonicsStateLoaded>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() generating,
    required TResult Function() appending,
    required TResult Function(String message) error,
    required TResult Function(String mnemonic, String? traceId) loaded,
  }) {
    return loaded(mnemonic, traceId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? generating,
    TResult? Function()? appending,
    TResult? Function(String message)? error,
    TResult? Function(String mnemonic, String? traceId)? loaded,
  }) {
    return loaded?.call(mnemonic, traceId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? generating,
    TResult Function()? appending,
    TResult Function(String message)? error,
    TResult Function(String mnemonic, String? traceId)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(mnemonic, traceId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MnemonicsStateGenerating value) generating,
    required TResult Function(MnemonicsStateAppending value) appending,
    required TResult Function(MnemonicsStateError value) error,
    required TResult Function(MnemonicsStateLoaded value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MnemonicsStateGenerating value)? generating,
    TResult? Function(MnemonicsStateAppending value)? appending,
    TResult? Function(MnemonicsStateError value)? error,
    TResult? Function(MnemonicsStateLoaded value)? loaded,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MnemonicsStateGenerating value)? generating,
    TResult Function(MnemonicsStateAppending value)? appending,
    TResult Function(MnemonicsStateError value)? error,
    TResult Function(MnemonicsStateLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class MnemonicsStateLoaded implements MnemonicsState {
  const factory MnemonicsStateLoaded(
      {required final String mnemonic,
      required final String? traceId}) = _$MnemonicsStateLoaded;

  String get mnemonic;
  String? get traceId;
  @JsonKey(ignore: true)
  _$$MnemonicsStateLoadedCopyWith<_$MnemonicsStateLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}
